"use strict";var D=Object.create;var w=Object.defineProperty;var F=Object.getOwnPropertyDescriptor;var M=Object.getOwnPropertyNames;var $=Object.getPrototypeOf,V=Object.prototype.hasOwnProperty;var z=(l,t)=>{for(var e in t)w(l,e,{get:t[e],enumerable:!0})},x=(l,t,e,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of M(t))!V.call(l,a)&&a!==e&&w(l,a,{get:()=>t[a],enumerable:!(i=F(t,a))||i.enumerable});return l};var S=(l,t,e)=>(e=l!=null?D($(l)):{},x(t||!l||!l.__esModule?w(e,"default",{value:l,enumerable:!0}):e,l)),q=l=>x(w({},"__esModule",{value:!0}),l);var X={};z(X,{default:()=>y});module.exports=q(X);var p=require("obsidian");var _=require("child_process"),O=require("util");var A=require("child_process"),H=require("util"),E=require("fs"),f=S(require("path")),g=S(require("os")),R=(0,H.promisify)(A.exec),L=(0,H.promisify)(E.access),v=class{constructor(){this.cachedPath=null;this.lastValidation=0;this.CACHE_TTL=5*60*1e3;this.COMMON_PATHS={darwin:["/opt/homebrew/bin/gh","/usr/local/bin/gh","/usr/bin/gh",f.join(g.homedir(),".local/bin/gh")],win32:[f.join(process.env.PROGRAMFILES||"C:\\Program Files","GitHub CLI","gh.exe"),f.join(process.env.LOCALAPPDATA||"","GitHub CLI","gh.exe"),f.join(process.env.PROGRAMFILES||"C:\\Program Files","gh","gh.exe"),"gh.exe"],linux:["/usr/bin/gh","/usr/local/bin/gh","/snap/bin/gh",f.join(g.homedir(),".local/bin/gh"),f.join(g.homedir(),"bin/gh")]}}async resolveGhPath(t){try{if(this.isCacheValid()&&this.cachedPath){if((await this.validateGhExecutable(this.cachedPath)).success)return{success:!0,path:this.cachedPath,method:"cached"};this.clearCache()}if(t&&(await this.validateGhExecutable(t)).success)return this.updateCache(t),{success:!0,path:t,method:"user-defined"};let e=g.platform(),i=this.COMMON_PATHS[e]||this.COMMON_PATHS.linux;for(let n of i)if(n)try{if((await this.validateGhExecutable(n)).success)return this.updateCache(n),{success:!0,path:n,method:"common-paths"}}catch(s){continue}if((await this.validateGhExecutable("gh")).success)try{let{stdout:n}=await R(e==="win32"?"where gh":"which gh",{timeout:3e3}),s=n.trim().split(`
`)[0];return this.updateCache(s),{success:!0,path:s,method:"environment-path"}}catch(n){return{success:!0,path:"gh",method:"environment-path"}}return{success:!1,error:"GitHub CLI (gh) not found in any expected locations. Please install GitHub CLI or configure the path manually in plugin settings."}}catch(e){return{success:!1,error:`Path resolution failed: ${e instanceof Error?e.message:"Unknown error"}`}}}async validateGhExecutable(t){try{if(t!=="gh"&&!t.includes("gh.exe"))try{await L(t,E.constants.F_OK),g.platform()!=="win32"&&await L(t,E.constants.X_OK)}catch(s){return{success:!1,error:`File does not exist or is not executable: ${t}`}}let e=t.includes(" ")?`"${t}" --version`:`${t} --version`,{stdout:i,stderr:a}=await R(e,{timeout:8e3,env:{...process.env,PATH:process.env.PATH}});return i.toLowerCase().includes("gh version")?{success:!0,path:t}:{success:!1,error:`Invalid GitHub CLI executable. Expected "gh version" in output, got: ${i.slice(0,100)}`}}catch(e){let i="Unknown validation error";return e.code==="ENOENT"?i=`GitHub CLI executable not found: ${t}`:e.code==="ETIMEDOUT"?i=`GitHub CLI validation timed out: ${t}`:e.stderr?i=`GitHub CLI validation failed: ${e.stderr}`:e.message&&(i=`GitHub CLI validation error: ${e.message}`),{success:!1,error:i}}}getInstallationInstructions(){switch(g.platform()){case"darwin":return'Install GitHub CLI using Homebrew: "brew install gh", or download from https://github.com/cli/cli/releases';case"win32":return'Install GitHub CLI using winget: "winget install GitHub.cli", or download from https://github.com/cli/cli/releases';case"linux":return"Install GitHub CLI using your package manager or download from https://github.com/cli/cli/releases";default:return"Download GitHub CLI from https://github.com/cli/cli/releases"}}clearCache(){this.cachedPath=null,this.lastValidation=0}getCacheStatus(){return this.cachedPath?{cached:!0,path:this.cachedPath,age:Date.now()-this.lastValidation}:{cached:!1}}isCacheValid(){return this.cachedPath!==null&&Date.now()-this.lastValidation<this.CACHE_TTL}updateCache(t){this.cachedPath=t,this.lastValidation=Date.now()}};var U=/^https?:\/\/github\.com\/[^\/]+\/[^\/]+\/issues\/\d+$/,N=/^https?:\/\/github\.com\/[^\/]+\/[^\/]+\/pull\/\d+$/;var m={GH_NOT_AVAILABLE:"GitHub CLI (gh) is not available. Plugin disabled.",FETCHING_TITLE:"Fetching GitHub title...",FETCH_SUCCESS:"GitHub URL converted to link",FETCH_FAILED:"Failed to fetch title. Using original URL.",FETCH_ERROR_PREFIX:"Failed to fetch title: "},C={SUCCESS:2e3,ERROR:4e3,PERSISTENT:0};var I=(0,O.promisify)(_.exec),h=class extends Error{constructor(t){super(t),this.name="GitHubError"}},T=class{constructor(t){this.settings=t;this.cache=new Map;this.resolvedGhPath=null;this.pathResolver=new v}async checkGhAvailability(){try{let t=await this.pathResolver.resolveGhPath(this.settings.ghPath);return t.success&&t.path?(this.resolvedGhPath=t.path,console.log(`GitHub CLI found at: ${t.path} (${t.method})`),!0):(console.error("GitHub CLI availability check failed:",t.error),this.resolvedGhPath=null,!1)}catch(t){return console.error("GitHub CLI availability check failed:",t),this.resolvedGhPath=null,!1}}isGitHubIssueUrl(t){return U.test(t.trim())}isGitHubPrUrl(t){return N.test(t.trim())}isGitHubResourceUrl(t){return this.isGitHubIssueUrl(t)||this.isGitHubPrUrl(t)}async fetchIssueTitle(t){var i,a,n;if(!this.isGitHubIssueUrl(t))throw new h("Invalid GitHub issue URL format");let e=this.getCachedTitle(t);if(e)return e;if(!this.resolvedGhPath){let s=await this.pathResolver.resolveGhPath(this.settings.ghPath);if(!s.success||!s.path)throw new h(`GitHub CLI not available: ${s.error}`);this.resolvedGhPath=s.path}try{let s=this.buildGhCommand(this.resolvedGhPath,t),{stdout:o}=await I(s,{timeout:8e3}),r=o.trim();if(!r)throw new h("Empty title received from GitHub CLI");return this.cacheTitle(t,r),r}catch(s){if(this.isPathRelatedError(s)&&this.resolvedGhPath){console.warn("GitHub CLI path seems invalid, attempting to re-resolve...",s.message),this.resolvedGhPath=null,this.pathResolver.clearCache();let r=await this.pathResolver.resolveGhPath(this.settings.ghPath);if(r.success&&r.path){this.resolvedGhPath=r.path;try{let u=this.buildGhCommand(this.resolvedGhPath,t),{stdout:c}=await I(u,{timeout:8e3}),b=c.trim();if(b)return this.cacheTitle(t,b),b}catch(u){}}}let o=m.FETCH_ERROR_PREFIX;throw s.code==="ETIMEDOUT"?o+="Request timed out":s.code==="ENOENT"?o+="GitHub CLI executable not found":(i=s.stderr)!=null&&i.includes("not found")?o+="Issue not found or repository is private":(a=s.stderr)!=null&&a.includes("authentication")?o+='GitHub authentication required. Run "gh auth login"':(n=s.stderr)!=null&&n.includes("rate limit")?o+="GitHub API rate limit exceeded. Please try again later":o+=s.message||"Unknown error occurred",new h(o)}}async fetchPrTitle(t){var i,a,n;if(!this.isGitHubPrUrl(t))throw new h("Invalid GitHub pull request URL format");let e=this.getCachedTitle(t);if(e)return e;if(!this.resolvedGhPath){let s=await this.pathResolver.resolveGhPath(this.settings.ghPath);if(!s.success||!s.path)throw new h(`GitHub CLI not available: ${s.error}`);this.resolvedGhPath=s.path}try{let s=this.buildGhCommand(this.resolvedGhPath,t),{stdout:o}=await I(s,{timeout:8e3}),r=o.trim();if(!r)throw new h("Empty title received from GitHub CLI");return this.cacheTitle(t,r),r}catch(s){if(this.isPathRelatedError(s)&&this.resolvedGhPath){console.warn("GitHub CLI path seems invalid, attempting to re-resolve...",s.message),this.resolvedGhPath=null,this.pathResolver.clearCache();let r=await this.pathResolver.resolveGhPath(this.settings.ghPath);if(r.success&&r.path){this.resolvedGhPath=r.path;try{let u=this.buildGhCommand(this.resolvedGhPath,t),{stdout:c}=await I(u,{timeout:8e3}),b=c.trim();if(b)return this.cacheTitle(t,b),b}catch(u){}}}let o=m.FETCH_ERROR_PREFIX;throw s.code==="ETIMEDOUT"?o+="Request timed out":s.code==="ENOENT"?o+="GitHub CLI executable not found":(i=s.stderr)!=null&&i.includes("not found")?o+="Pull request not found or repository is private":(a=s.stderr)!=null&&a.includes("authentication")?o+='GitHub authentication required. Run "gh auth login"':(n=s.stderr)!=null&&n.includes("rate limit")?o+="GitHub API rate limit exceeded. Please try again later":o+=s.message||"Unknown error occurred",new h(o)}}async fetchTitle(t){if(this.isGitHubIssueUrl(t))return this.fetchIssueTitle(t);if(this.isGitHubPrUrl(t))return this.fetchPrTitle(t);throw new h("Invalid GitHub URL format")}getCachedTitle(t){let e=this.cache.get(t);return e?Date.now()-e.timestamp>this.settings.cacheTtl*60*1e3?(this.cache.delete(t),null):(this.cache.size>1&&(this.cache.delete(t),this.cache.set(t,e)),e.title):null}cacheTitle(t,e){if(this.cache.size>=this.settings.cacheSize){let i=this.cache.keys().next().value;i&&this.cache.delete(i)}this.cache.set(t,{title:e,timestamp:Date.now()})}clearCache(){this.cache.clear()}getCacheStats(){return{size:this.cache.size,maxSize:this.settings.cacheSize}}buildGhCommand(t,e){let i=t.includes(" ")?`"${t}"`:t;if(this.isGitHubIssueUrl(e))return`${i} issue view "${e}" --json title -q .title`;if(this.isGitHubPrUrl(e))return`${i} pr view "${e}" --json title -q .title`;throw new h("Unsupported GitHub URL format")}isPathRelatedError(t){var e,i,a;return t.code==="ENOENT"||((e=t.message)==null?void 0:e.includes("command not found"))||((i=t.message)==null?void 0:i.includes("not found"))||((a=t.stderr)==null?void 0:a.includes("command not found"))}getCurrentGhPath(){return this.resolvedGhPath}async refreshGhPath(){return this.resolvedGhPath=null,this.pathResolver.clearCache(),await this.checkGhAvailability()}};var d=require("obsidian");var k={enabled:!0,cacheTtl:60,cacheSize:100,showNotifications:!0,supportedResourceTypes:["issues"]},G=class extends d.PluginSettingTab{constructor(e,i){super(e,i);this.plugin=i,this.pathResolver=new v}display(){let{containerEl:e}=this;e.empty(),e.createEl("h2",{text:"GitHub Issue Linker Settings"}),new d.Setting(e).setName("Enable plugin").setDesc("Turn the GitHub Issue Linker on or off").addToggle(a=>a.setValue(this.plugin.settings.enabled).onChange(async n=>{this.plugin.settings.enabled=n,await this.plugin.saveSettings()})),new d.Setting(e).setName("Cache TTL (minutes)").setDesc("How long to cache issue titles before refetching (minimum: 1 minute)").addText(a=>{let n=a.setPlaceholder("60").setValue(String(this.plugin.settings.cacheTtl)).onChange(async o=>{let r=Number(o);Number.isInteger(r)&&r>0?(this.plugin.settings.cacheTtl=r,await this.plugin.saveSettings(),s.textContent="",s.style.color=""):(s.textContent="Please enter a positive integer",s.style.color="var(--text-error)")}),s=e.createEl("div",{cls:"setting-item-description",text:""});return n}),new d.Setting(e).setName("Cache size").setDesc("Maximum number of issue titles to cache (minimum: 10)").addText(a=>{let n=a.setPlaceholder("100").setValue(String(this.plugin.settings.cacheSize)).onChange(async o=>{let r=Number(o);Number.isInteger(r)&&r>=10?(this.plugin.settings.cacheSize=r,await this.plugin.saveSettings(),s.textContent="",s.style.color=""):(s.textContent="Please enter an integer of 10 or more",s.style.color="var(--text-error)")}),s=e.createEl("div",{cls:"setting-item-description",text:""});return n}),new d.Setting(e).setName("Show notifications").setDesc("Display success and error notifications when processing GitHub URLs").addToggle(a=>a.setValue(this.plugin.settings.showNotifications).onChange(async n=>{this.plugin.settings.showNotifications=n,await this.plugin.saveSettings()})),new d.Setting(e).setName("GitHub CLI Path").setDesc("Custom path to GitHub CLI executable (leave empty for auto-detection)").addText(a=>{let n=a.setPlaceholder("Auto-detect (recommended)").setValue(this.plugin.settings.ghPath||"").onChange(async c=>{s.textContent="",s.className="setting-item-description",this.plugin.settings.ghPath=c.trim()||void 0,await this.plugin.saveSettings(),c.trim()&&this.validateGhPath(c.trim(),s)}),s=e.createEl("div",{cls:"setting-item-description",text:""}),o=e.createEl("div",{cls:"setting-item-control"}),r=o.createEl("button",{text:"Auto-detect",cls:"mod-cta"});r.onclick=async()=>{s.textContent="Detecting GitHub CLI...",s.className="setting-item-description";let c=await this.pathResolver.resolveGhPath();c.success&&c.path?(n.setValue(c.path),this.plugin.settings.ghPath=c.path,await this.plugin.saveSettings(),s.textContent=`\u2713 Found GitHub CLI at: ${c.path} (${c.method})`,s.style.color="var(--text-success)"):(s.textContent=`\u2717 ${c.error}`,s.style.color="var(--text-error)")};let u=o.createEl("button",{text:"Test"});return u.style.marginLeft="8px",u.onclick=async()=>{let c=n.getValue().trim()||void 0;await this.validateGhPath(c,s)},n}).addExtraButton(a=>{a.setIcon("info").setTooltip("GitHub CLI installation instructions").onClick(()=>{let n=this.pathResolver.getInstallationInstructions(),s=new(require("obsidian")).Modal(this.app);s.titleEl.setText("GitHub CLI Installation"),s.contentEl.createEl("p",{text:n}),s.contentEl.createEl("p",{text:'After installation, restart Obsidian and use the "Auto-detect" button.'}),s.open()})}),new d.Setting(e).setName("Supported resource types").setDesc("Types of GitHub resources to convert to links").addDropdown(a=>a.addOption("issues","Issues only").addOption("prs","Pull Requests only").addOption("both","Issues and Pull Requests").setValue(this.plugin.settings.supportedResourceTypes.includes("prs")?this.plugin.settings.supportedResourceTypes.includes("issues")?"both":"prs":"issues").onChange(async n=>{n==="issues"?this.plugin.settings.supportedResourceTypes=["issues"]:n==="prs"?this.plugin.settings.supportedResourceTypes=["prs"]:this.plugin.settings.supportedResourceTypes=["issues","prs"],await this.plugin.saveSettings()})),e.createEl("h3",{text:"Usage"}),e.createEl("p",{text:"Simply paste a GitHub Issue or Pull Request URL into any Obsidian note, and it will be automatically converted to a Markdown link with the resource title."}),e.createEl("h3",{text:"Prerequisites"});let i=e.createEl("ul");i.createEl("li",{text:"GitHub CLI (gh) must be installed on your system"}),i.createEl("li",{text:'You must be authenticated with GitHub via "gh auth login"'}),e.createEl("p",{text:"If the GitHub CLI is not available, the plugin will be automatically disabled."})}async validateGhPath(e,i){var a;i.textContent="Validating GitHub CLI...",i.className="setting-item-description",i.style.color="";try{let n=await this.pathResolver.resolveGhPath(e);if(n.success&&n.path)i.textContent=`\u2713 GitHub CLI is working: ${n.path}`,i.style.color="var(--text-success)";else{i.textContent=`\u2717 ${n.error}`,i.style.color="var(--text-error)";let s=(a=i.parentElement)==null?void 0:a.createEl("div",{cls:"setting-item-description"});s&&(s.style.marginTop="8px",s.style.padding="8px",s.style.backgroundColor="var(--background-secondary)",s.style.borderRadius="4px"),s&&(s.createEl("strong",{text:"Installation Instructions:"}),s.createEl("br"),s.createEl("span",{text:this.pathResolver.getInstallationInstructions()}))}}catch(n){i.textContent=`\u2717 Validation failed: ${n instanceof Error?n.message:"Unknown error"}`,i.style.color="var(--text-error)"}}};var y=class extends p.Plugin{constructor(){super(...arguments);this.isPluginEnabled=!1}async onload(){if(console.log("Loading GitHub Issue Linker plugin"),await this.loadSettings(),this.githubService=new T(this.settings),!this.settings.enabled){console.log("GitHub Issue Linker plugin is disabled in settings"),this.addSettingTab(new G(this.app,this));return}if(!await this.githubService.checkGhAvailability()){new p.Notice(m.GH_NOT_AVAILABLE,C.ERROR),console.error("GitHub CLI (gh) is not available. Plugin disabled."),this.addSettingTab(new G(this.app,this));return}this.isPluginEnabled=!0,this.registerDomEvent(document,"paste",this.handlePaste.bind(this)),this.addSettingTab(new G(this.app,this)),console.log("GitHub Issue Linker plugin loaded successfully")}onunload(){console.log("Unloading GitHub Issue Linker plugin"),this.isPluginEnabled=!1}async handlePaste(e){var s;if(!this.isPluginEnabled||!this.settings.enabled)return;let i=this.app.workspace.getActiveViewOfType(p.MarkdownView);if(!(i!=null&&i.editor))return;let a=i.editor,n=(s=e.clipboardData)==null?void 0:s.getData("text/plain");n&&this.githubService.isGitHubResourceUrl(n)&&(e.preventDefault(),e.stopPropagation(),setTimeout(async()=>{await this.processUrlConversion(a,n)},10))}async processUrlConversion(e,i){let a=e.getCursor(),n=e.getLine(a.line),s=a;if(n.includes(i)){let r=n.indexOf(i);if(r>=0){let u={line:a.line,ch:r},c={line:a.line,ch:r+i.length};e.setSelection(u,c),s=u}}let o=null;this.settings.showNotifications&&(o=new p.Notice(m.FETCHING_TITLE,C.PERSISTENT));try{let r=await this.githubService.fetchTitle(i),u=`[${r}](${i})`;e.replaceSelection(u),o&&o.hide(),this.settings.showNotifications&&new p.Notice(m.FETCH_SUCCESS,C.SUCCESS),console.log(`Successfully converted GitHub issue URL to link: ${r}`)}catch(r){o&&o.hide(),this.settings.showNotifications&&new p.Notice(m.FETCH_FAILED,C.ERROR),n.includes(i)||(e.setCursor(s),e.replaceSelection(i)),r instanceof h?console.error("GitHub Issue Linker error:",r.message):console.error("GitHub Issue Linker unexpected error:",r)}}async loadSettings(){this.settings=Object.assign({},k,await this.loadData())}async saveSettings(){if(await this.saveData(this.settings),this.githubService&&this.settings.enabled)try{await this.githubService.refreshGhPath()}catch(e){console.warn("Failed to refresh GitHub CLI path after settings change:",e)}}getStatus(){var e;return{enabled:this.settings.enabled,pluginEnabled:this.isPluginEnabled,cacheStats:((e=this.githubService)==null?void 0:e.getCacheStats())||{size:0,maxSize:0}}}};
